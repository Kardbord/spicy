#! /bin/sh
#
# Generates a readable representation of the current version number; with
# --short a short one. Or alternatively with --header, a version.h file with
# various constants defined accordingly.

usage() {
    echo "usage $(basename $0) [--short|--header <file>|--cmake] [--git-root <dir>] [<commit>]"
}

output=long

while [ $# -ge 1 ]; do
    if [ "$1" = "--short" ]; then
        output=short
        shift
    elif [ "$1" = "--header" ]; then
        test $# -lt 2 && usage && exit 1
        output=header
        dst=$2
        shift
        shift
    elif [ "$1" = "--cmake" ]; then
        output=cmake
        shift
    elif [ "$1" = "--git-root" ]; then
        test $# -lt 2 && usage && exit 1
        cd $2
        shift
        shift
    fi
done

if [ $# != 0 -a $# != 1 ]; then
    usage
    exit 1
fi

ref=HEAD
describe_arg="--dirty"

test -n "$1" && test "$1" != "HEAD" && ref="$1" && describe_arg="$1"

branch=$(git symbolic-ref --short "${ref}" 2>/dev/null)

# When running from CI, for geting the branch name we prefer what
# might be passed in through environment variables as we may not
# actually be on a branch.
test -n "${CI_COMMIT_REF_NAME}" && branch=${CI_COMMIT_REF_NAME} # GitLab
test -n "${CIRRUS_BRANCH}" && branch=${CIRRUS_BRANCH} # Cirrus CI

describe=$(git describe --always --match "v*" "${describe_arg}" | sed 's/^v//g')

version=$(echo "${describe}" | awk -F - '{print $1}' | sed 's/^v//g')
commit=$(echo "${describe}" | awk -F - '{print $2}')
hash=$(git rev-parse --short "${ref}")
dirty=$(echo "${describe}" | awk -F - '{print $4}')

test -n "${commit}" -a -n "${dirty}" && commit="${commit}.${dirty}"

case "${branch}" in
    master)
        # As we don't have (actual or anticipated) releases yet, we use the old
        # Zeek scheme for now: commits since last tag.
        prerelease="${commit}"
        # prerelease="dev-${commit}"
        ;;

    release/*)
        prerelease="${commit}"
        ;;

    "")
        prerelease="${commit}"
        ;;

    *)
        prerelease="branch"
        hash=""
        ;;
esac

test -n "${prerelease}" && str_prerelease="-${prerelease}"

str_branch="${branch}"
test -n "${branch}" -a -n "${hash}" && str_branch="${branch} "

major=$(echo "${version}" | cut -d '.' -f 1)
minor=$(echo "${version}" | cut -d '.' -f 2)
patch=$(echo "${version}" | cut -d '.' -f 3)

test -z "${major}" && major=0
test -z "${minor}" && minor=0
test -z "${patch}" && patch=0

version_number=$((${major} * 10000 + ${minor} * 100 + ${patch}))

if [ "${output}" = "long" ]; then
    echo "${version}${str_prerelease} (${str_branch}${hash})"

elif [ "${output}" = "short" ]; then
    echo "${version}${str_prerelease}"

elif [ "${output}" = "header" ]; then
    trap "rm -f '${dst}.tmp'" EXIT
    cat >"${dst}.tmp" <<EOF
/* Autogenerated. Do not edit.
VERSION ${version}${str_prerelease}
*/
#define PROJECT_VERSION_NUMBER       ${version_number}
#define PROJECT_VERSION_MAJOR        ${major}
#define PROJECT_VERSION_MINOR        ${minor}
#define PROJECT_VERSION_PATCH        ${patch}
#define PROJECT_VERSION_PRERELEASE   "${prerelease}"
#define PROJECT_VERSION_STRING_SHORT "${version}${str_prerelease}"
#define PROJECT_VERSION_STRING_LONG  "${version}${str_prerelease} (${str_branch}${hash})"
EOF

    test -e "${dst}" && cmp -s "${dst}.tmp" "${dst}" && exit 0
    mv "${dst}.tmp" "${dst}"

elif [ "${output}" = "cmake" ]; then
    echo "${version}"

fi
