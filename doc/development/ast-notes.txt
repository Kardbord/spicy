Main changes:

    - Switched to traditional class hierarchy for AST nodes, with
      `Node` at the top.

    - Modeling type constness with a new node `QualifiedType`, instead
      of coding it into all `Type` instances. `Type` has been renamed
      into `UnqualifiedType` for easier distinguishing and so that the
      compiler will catch existing usage of the old `Type` that hasn't
      been updated. We also use `QualifiedType` to track LHS/RHS
      semantics.

    - IDs are no longer nodes themselves, just node attributes like
      other atomic values.

    - We now instantiate all nodes through static factory methods
      called `create()` that take an additional global `ASTContext`
      instance, which maintains AST-wide state. To facilitate this
      approach, all node constructors are private now; the caller must
      go through the `create()` methods.

    - The AST context holds all modules inside a single, global AST
      (previously, we have one AST per module). The root of this
      single AST is a node `ASTRoot`, and the immediate children of
      that node are the modules (`declaration::Module`). This
      structure significantly simplifies cross-module processing.
      Visitors now traverse the full global tree, seeing all modules
      at once.

    - To make usage of the `create()` methods easier, there's a new
      `NodeFactory` class that provides forwarding methods. The
      factory stores the relevant `ASTContext` internally and
      automatically adds it during forwarding. This factory also
      replaces the old `builder::*` functions for creating AST nodes.

      The forwarding methods are automatically generated through
      `scripts/autogen-builder-api` (which, in turn, uses a
      `libclang`-based tool `bin/autogen-builder-api`).

    - Nodes now keep pointers to their parents. That replaces the
      old `position_t` stuff.

    - No singleton nodes anymore, they don't play well with that
      parent pointering.

    - No `node::None` anymore, using `nullptr` instead. Likewise, no
      `optional<SomeNode>` anymore, using `nullptr` as well.

    - For visitors, we're using traditional double-dispatch with
      virtual methods. No more complex template magic, and no more
      result values from visitors either. There are just two visitor
      variants now for pre-order and post-order walking (and those two
      are still implemented through a joined template). Plus, there
      are HILTI and Spicy version of each visitor. The Spicy-version
      adds additional virtual methods for Spicy-specific nodes.

    - Unresolved types: Use `Auto` if the type is presumably still
      going to be resolved, and `Unknown` if the type has been
      determined to be finally unresolvable.

    - To render AST nodes in a way that's user-presentable, use
      `print()` methods. In contrast, `dump()` is limited to dump out
      debug information, in particular the AST

    - Resolver/coercer/normalizer have all merged into a new, single
      pass called "resolver". The previous separation was confusing
      and hard to maintain.

    - The passes that were formerly in `compiler/visitors/*.cc` have
      moved up a level and gained their own header files to declare
      their entry points. No more `global.h` either.

    - No cycles are allowed inside the AST. That means a child cannot
      point back to a node that's already elsewhere in the AST. That
      also means, each node does have a unique parent. When adding a
      node to an AST that already has a parent, the node is
      deep-copied automatically (see next bullet). In case something
      goes wrong, debug builds run a cycle detector to catch problems.

    - When adding a node to an AST (i.e., as the child of another
      Node), there are two cases:

        1. It's a new node instance that does not have a parent yet.
           In that case, we directly add a pointer to that Node as the
           child.

        2. It's a node instance that already has a different parent.
           In that case, we deep-copy the node first and add a pointer
           to the copy as the child.

       Note that when wanting to *move* a node from one location
       inside the AST to another, you can avoid the deep-copy by first
       removing it from its old parent (which will clear the parent
       pointer) and then adding it to the new parent.

       Conceptually, there are two main places where this logic
       happens: 1. when manipulating the child of a Node through the
       corresponding Node methods; and 2. when instantiating new Node
       and given them their initial children. Generally, this all happens
       automatically when going through the corresponding methods,
       which deep-copy on-demand as needed.

    - If we *semantically* do need a cycle, the solution is to store a
      reference (see next bullet) to the target inside an explicit
      node attribute that's not part of the normal parent/child
      pointering. Examples of nodes doing this are `expression::Name`,
      `type::Name`, and `QualifiedType`. The latter has the notion of
      "external" types where the wrapped `UnqualifiedType` is not a
      child, but stored somewhere else inside the AST; the
      `QualifiedType` just stores a reference to it, which it
      transparently unwraps when the `UnqualifiedType` is requested
      (through `type()`).

    - The "references" mentioned above are implemented through
      mappings inside the ASTContext. Currently, this is supported for
      declarations and types. First, one registers the
      declaration/type with the AST context. That assigns it a unique,
      stable index ID. That index acts as the reference that nodes can
      store as attributes. To dereference, one can later ask the context to
      provide the declaration/type that corresponds to the stored index.

    - Non-abstract classes derived from Node
        - Public `create()` factory
        - Protected constructors, called from `create()`
        - Protected copy/move constructors/assignment that perform shallow copies.

    - We do type comparison by computing a serialized version of each
      type, call "type unification". We  then comparing those
      unifications as strings. An empty unification always compares
      false against anything else.

    - When comparing types, we distinguish between types that are
      compared structurally (most) and by name ("name types"; e.g.,
      struct and enums). A virtual type method `isNameType()`
      indicates of which kind a type is.
